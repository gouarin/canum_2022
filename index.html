<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="icon" type="image/svg+xml" href="favicon.svg" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- <link rel="stylesheet" href="/black.css" id="theme"> -->
  <!-- <link rel="stylesheet" href="/theme/light.css" id="theme"> -->
  <link rel="stylesheet" href="/theme/light.css" id="theme">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet"
    integrity="sha384-1BmE4kWBq78iYhFldvKuhfTAU6auU8tT94WrHftjDbrCEXSU1oBoqyl2QvZ6jIW3" crossorigin="anonymous">

  <title>Samurai - CANUM 2022</title>
</head>

<body>
  <div class="reveal">
    <div class="slides">
      <section>
        <div class="row">
          <div class="col-8">
            <img src="./figures/logo.png">
          </div>
          <div class="col-4 align-self-center text-end">
            <h1 class="title-talk">Samurai</h1>
            <p class="subtitle-talk">CANUM 2022</p>
            <p class="subtitle-talk">Loïc Gouarin</p>
          </div>
        </div>
      </section>

      <section data-menu-title="Context">
        <section>
          <h1>Context</h1>
          <hr>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">Mesh adaptation</h1>
            </div>
            <div class="main">
              <div class="row">
                <div class="col">
                  <img id="adapt" src="figures/patch_based_light.png">
                </div>
                <div class="col">
                  <img id="adapt" src="figures/cell_based_light.png">
                </div>
              </div>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">Tree data structure</h1>
            </div>
            <div class="main">
              <video id="adapt" data-autoplay src="/videos/tree_light.mp4"/>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">Tree data structure : Z-curve</h1>
            </div>
            <div class="main">
              <video data-autoplay src="/videos/mesh_2d_scene_1_light_0000.mp4"/>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">Tree data structure : Z-curve</h1>
            </div>
            <div class="main">
              <video data-autoplay src="/videos/mesh_2d_scene_1_light_0001.mp4"/>
            </div>
          </div>
        </section>

        <section class="d-flex align-content-end">
          <div >
              <p>Most of the open source software dedicated to adaptive mesh refinement focus on the mesh and not on the numerical schemes defined on a cartesian grid.</p>
              <p>As a result, the API can be difficult to use
             and code on uniform meshes must be rewritten.</p>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">Design principles of Samurai</h1>
            </div>
          <div class="main">
            <ul>
              <li class="fragment">Compress the mesh according to the level-wise spatial connectivity along each Cartesian axis</li>
              <li class="fragment">Achieve fast look-up for a cell into the structure</li>
              <li class="fragment">Maximize the memory contiguity of the stored data to allow for caching and vectorization</li>
              <li class="fragment">Facilitate inter-level operations which are common in many numerical techniques</li>
              <li class="fragment">Allow for a time evolution of the hybrid mesh in an efficient manner</li>
              <li class="fragment">Give the possibility of writing numerical schemes in a transparent way as one were on a uniform mesh</li>
            </ul>
          </div>
        </div>
      </section>
    </section>

    <section data-menu-title="Concepts">
      <section>
          <h1>Core Concepts of Samurai</h1>
          <hr>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">1D example of adapted mesh</h1>
            </div>
            <div class="main">
              <video id="adapt" data-autoplay src="/videos/mesh_scene_1_light.mp4"/>
            </div>
            </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">1D example of adapted mesh</h1>
            </div>
            <div class="main">
              <video id="adapt" data-autoplay src="/videos/mesh_scene_2_light.mp4"/>
            </div>
            </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">1D example of adapted mesh</h1>
            </div>
            <div class="main">
              <video id="adapt" data-autoplay src="/videos/mesh_scene_3_light.mp4"/>
            </div>
            </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">1D example of adapted mesh</h1>
            </div>
            <div class="main">
              <video id="adapt" data-autoplay src="/videos/mesh_scene_4_light.mp4"/>
            </div>
            </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
          <h1 class="title">Summary of constraints</h1>
        </div>
        <div class="main">
            <ul>
              <li class="fragment">A refined cell is split into 2 in 1d, 4 in 2d and 8 in 3d equal parts.</li>
              <li class="fragment">At a given resolution level, the size of the cells is equal.</li>
              <li class="fragment">The size of the cells is defined by the resolution level.</li>
              <li class="fragment">A cell is represented by an integer.</li>
              <li class="fragment">The adapted mesh is generally graded.</li>
            </ul>
          </div>
        </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">The interval</h1>
            </div>
            <div class="main text-center">
              <span class="interval_symb">[</span>
              <span class="interval_bound">start</span>
              <span class="interval_symb">,</span>
              <span class="interval_bound">end</span>
              <span class="interval_symb">[ @ </span>
              <span class="interval_offset">offset</span>
              <span class="interval_symb">:</span>
              <span class="interval_step">step</span>
            </div>
            </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">The interval</h1>
            </div>
            <div class="main">
              <video id="adapt" data-autoplay src="/videos/interval_scene_1_light.mp4"/>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">Field numbering</h1>
            </div>
            <div class="main">
              <video id="adapt" data-autoplay src="/videos/interval_scene_2_light.mp4"/>
            </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">What happens in N-D ?</h1>
            </div>
            <div class="main text-center">
              <p>This process is completely</p>
              <p>recursive !</p>
            </div>
          </div>
        </section>

      </section>
      <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">Algebra of sets</h1>
            </div>
            <div class="main">
              <p>The search of an admissible set is again recursive. The algorithm starts from the last dimension (y in 2d, z in 3d, …).</p>

              <p>The available operators in samurai are for now</p>
              <ul>
                <li>the <span>intersection</span> of sets,</li>
                <li>the <span>union</span> of sets,</li>
                <li>the <span>difference</span> between two sets,</li>
                <li>the <span>translation</span> of a set,</li>
                <li>the <span>extension</span> of a set.</li>
              </ul>
            </div>
            </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">Other features</h1>
            </div>
            <div class="main">
              <ul>
                <li>Loop algorithms over the levels and the cells</li>
                <li>Simplified access operator</li>
                <li>Helper classes to construct complex meshes</li>
                <li>Helper classes to construct N-D operators and expressions using xtensor</li>
                <li>HDF5 support</li>
              </ul>
            </div>
            </div>
        </section>

        <section data-menu-title="examples">
          <section>
            <h1>Examples</h1>
            <hr>
          </section>

          <section>
            <h1>The projection operator</h1>
            <hr>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">An example</h1>
              </div>
              <div class="main">
                <video id="adapt" data-autoplay src="/videos/projection_light.mp4"/>
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">The implementation</h1>
              </div>
              <div class="main">
                <pre><code class="cpp">
auto u = samurai::make_field&lt;double, 1&gt;("u", mesh);
...
auto set = samurai::intersection(mesh[level], mesh[level + 1])
          .on(level);

set([&](const auto& i, auto)
{
    u(level, i) = 0.5*(u(level + 1, 2*i) + u(level + 1, 2*i + 1));
});
                </code></pre>
              </div>
            </div>
          </section>

          <section>
            <h1>Creation of random meshes and their graduation</h1>
            <hr>
          </section>

          <section>
                <div class="row">
                  <div class="col-6">
                <img src="/figures/graduation_before.png"/>
                before
              </div>
              <div class="col-6">
                <img src="/figures/graduation_after.png"/>
                after
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">Create a mesh</h1>
              </div>
              <div class="main">
                <pre><code class="cpp">
constexpr std::size_t dim = 2;
std::size_t start_level = 1;
std::size_t max_refinement_level = 7;

samurai::Box&lt;int, dim&gt; box({0, 0}, {1&lt;&lt;start_level, 1&lt;&lt;start_level});

samurai::CellArray&lt;dim&gt; ca;
ca[start_level] = {start_level, box};
                  </code></pre>
                </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">Add cells randomly</h1>
              </div>
              <div class="main">
                <pre><code class="cpp">
samurai::CellList&lt;dim&gt; cl;

samurai::for_each_interval(ca, [&](std::size_t level, const auto& interval, const auto& index)
{
    auto choice = xt::random::choice(xt::xtensor_fixed&lt;bool, xt::xshape&lt;2&gt;&gt;{true, false}, interval.size());

    for(int i = interval.start, ic = 0; i&lt;interval.end; ++i, ++ic)
    {
        if (choice[ic])
        {
            cl[level + 1][2*index].add_interval({2*i, 2*i+2});
            cl[level + 1][2*index + 1].add_interval({2*i, 2*i+2});
        }
        else
        {
            cl[level][index].add_point(i);
        }
    }
});

ca = {cl, true};
                  </code></pre>
                </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">Tag cells to refine</h1>
              </div>
              <div class="main">
                <pre><code class="cpp">
std::size_t min_level = ca.min_level(), max_level = ca.max_level();
xt::xtensor_fixed&lt;int, xt::xshape&lt;4, dim&gt;&gt; stencil{{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

auto tag = samurai::make_field&lt;bool, 1&gt;("tag", ca);
tag.fill(false);

for(std::size_t level = min_level + 2; level &lt;= max_level; ++level)
{
    for(std::size_t level_below = min_level; level_below &lt; level - 1; ++level_below)
    {
        for(std::size_t i = 0; i &lt; stencil.shape()[0]; ++i)
        {
            auto s = xt::view(stencil, i);
            auto set = samurai::intersection(samurai::translate(ca[level], s), ca[level_below])
                      .on(level_below);
            set([&](const auto& i, const auto& index)
            {
                tag(level_below, i, index[0]) = true;
            });
        }
    }
}
                  </code></pre>
                </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">Create a new mesh from the tag</h1>
              </div>
              <div class="main">
                <pre><code class="cpp">
samurai::CellList&lt;dim&gt; cl;

samurai::for_each_cell(ca, [&](auto cell)
{
    auto i = cell.indices[0];
    auto j = cell.indices[1];

    if (tag[cell])
    {
        cl[cell.level + 1][{2*j}].add_interval({2*i, 2*i+2});
        cl[cell.level + 1][{2*j + 1}].add_interval({2*i, 2*i+2});
    }
    else
    {
        cl[cell.level][{j}].add_point(i);
    }
});

samurai::CellArray&lt;dim&gt; new_ca = {cl, true};
                  </code></pre>
                </div>
            </div>
          </section>

          <section>
            <h1>The advection equation</h1>
            <hr>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">The problem</h1>
              </div>
              <div class="main">
                We consider the well known linear advection equation
                $$
                \frac{\partial u}{\partial t} + a\frac{\partial u}{\partial x} = 0 \quad \text{with} \: a>0,
                $$
                with the initial condition
                $$
                u(., 0) = e^{-50x^2} \quad \text{for} \: x \in [0, 1[.
                $$
                And we use the upwind scheme
                $$
                \frac{u^{n+1}_i - u^n_i}{\Delta t} + a \frac{u^{n}_i - u^n_{i-1}}{\Delta x} = 0.
                $$
              </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">The initialization (1d)</h1>
              </div>
              <div class="main">
                <pre><code class="cpp">
template&lt;class Mesh&gt;
auto init(Mesh& mesh)
{
    auto field = samurai::make_field&lt;double, 1&gt;("u", mesh);

    samurai::for_each_cell(mesh, [&](auto& cell)
    {
        auto x = cell.center(0);

        field[cell] = std::exp(-50*x*x);
    });

    return field;
}
                  </code></pre>
                </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">The initialization (2d)</h1>
              </div>
              <div class="main">
                <pre><code class="cpp">
template&lt;class Mesh&gt;
auto init(Mesh& mesh)
{
    auto field = samurai::make_field&lt;double, 1&gt;("u", mesh);

    samurai::for_each_cell(mesh, [&](auto& cell)
    {
        auto x = cell.center(0);
        auto y = cell.center(1);

        field[cell] = std::exp(-50*(x*x + y*y));
    });

    return field;
}
                  </code></pre>
                </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">Upwind scheme as an expression</h1>
              </div>
              <div class="main">
                <pre><code class="cpp">
template&lt;class TInterval&gt;
class upwind_op : public samurai::field_operator_base&lt;TInterval&gt;,
                  public samurai::field_expression&lt;upwind_op&lt;TInterval&gt;&gt;
{
    public:
        INIT_OPERATOR(upwind_op)

        template&lt;class Field&gt;
        inline auto operator()(samurai::Dim&lt;1&gt;, const Field& u) const
        {
            double dx = 1./(1&lt;&lt;level);
            return (u(level, i) - u(level, i-1))/dx;
        }

        template&lt;class Field>
        inline auto operator()(samurai::Dim&lt;2&gt;, const Field& u) const
        {
            double dx = 1./(1&lt;&lt;level);
            return (u(level, i, j) - u(level, i-1, j) + u(level, i, j) - u(level, i, j-1))/dx;
        }
};

template&lt;class... CT>
inline auto upwind(CT &&... e)
{
    return samurai::make_field_operator_function&lt;upwind_op&gt;(std::forward&lt;CT&gt;(e)...);
}
                  </code></pre>
                </div>
            </div>
          </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">Simulation on uniform mesh</h1>
              </div>
              <div class="main">
                <pre><code class="cpp">
for(std::size_t ite=0; ite&lt;200; ++ite)
{
    samurai::update_ghost_mr(field, update_bc);

    field_np1 = field - dt*upwind(field);

    std::swap(field.array(), field_np1.array());

    samurai::save(fmt::format("mesh_{}", ite+1), mesh, field);
}
                </code></pre>
              </div>
          </div>
        </section>

        <section>
          <div class="sl-block">
            <div class="header">
              <h1 class="title">Simulation with adaptive mesh refinement</h1>
            </div>
            <div class="main">
              <pre><code class="cpp">
auto MRadaptation = samurai::make_MRAdapt(field, update_bc);
double eps = 1e-4;
double regularity = 2;

for(std::size_t ite=0; ite&lt;200; ++ite)
{
  if (max_level &gt; min_level)
  {
      MRadaptation(eps, regularity);
  }

  samurai::update_ghost_mr(field, update_bc);

  field_np1 = field - dt*upwind(field);

  std::swap(field.array(), field_np1.array());

  samurai::save(fmt::format("mesh_{}", ite+1), mesh, field);
}
              </code></pre>
            </div>
        </div>
      </section>

      <section>
            <video data-autoplay src="/videos/advection_2d_high.mp4"/>
      </section>

        </section>

          <section>
            <div class="sl-block">
              <div class="header">
                <h1 class="title">Ongoing work</h1>
              </div>
              <div class="main" style="font-size: 20px">
                <ul>
                  <li>Lattice Boltzmann methods and multiresolution - <strong>Thomas Bellotti</strong> - LMO</li>
                  <li>Magnetism plasma column - <strong>Louis Reboul</strong> and <strong>Alejandro Alvarez</strong> - LPP</li>
                  <li>Task-based parallelism for adaptive mesh refinement - <strong>Kevin Barré</strong> - Onera, Google</li>
                  <li>Direct numerical simulation of lithium-ion batteries based on high-resolution 3D images of porous electrode microstructures - <strong>Ali Asad</strong> - Total</li>
                  <li>Sharp interface method for low Mach two-phase flows - <strong>Nicolas Grenier</strong> et <strong>Christian Tenaud</strong> - LIMSI, EM2C</li>
                  <li>Low-Mach reactive flows - <strong>Christian Tenaud</strong> et <strong>Laurent Series</strong> - EM2C</li>
                </ul>
              </div>
            </div>
          </section>

          <section>
            <div class="row">
              <div class="col-6">
                <img src="./figures/logo.png">
              </div>
              <div class="col-6 align-self-center text-end">
                <h1 class="title-talk">Samurai</h1>
                <a href="https://github.com/hpc-maths/samurai">https://github.com/hpc-maths/samurai</a>
              </div>
            </div>
          </section>

          </div>
  </div>
  <script type="module" src="/main.js"></script>

</body>

</html>
